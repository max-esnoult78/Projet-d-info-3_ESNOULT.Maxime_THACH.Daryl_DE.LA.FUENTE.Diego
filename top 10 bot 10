#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOP_N 10

// --- Définition des structures ---
typedef struct {
    char id[10];          // Identifiant de la station
    char parentId[10];    // Identifiant de la station parente
    char name[50];        // Nom de la station
    long capacity;        // Capacité de transfert (kWh)
    long consumption;     // Consommation totale (kWh)
} Station;

typedef struct NodeAVL {
    Station station;          // Données de la station
    struct NodeAVL *left;     // Sous-arbre gauche
    struct NodeAVL *right;    // Sous-arbre droit
    int height;               // Hauteur du nœud
} NodeAVL;

// --- Fonctions utilitaires AVL ---
int height(NodeAVL *node) {
    return node ? node->height : 0;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}

// --- Création et gestion des nœuds ---
NodeAVL *createNode(Station station) {
    NodeAVL *node = (NodeAVL *)malloc(sizeof(NodeAVL));
    if (!node) {
        perror("Erreur d'allocation mémoire pour un nœud");
        exit(EXIT_FAILURE);
    }
    node->station = station;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;
    return node;
}

// --- Rotation droite pour équilibrage ---
NodeAVL *rotateRight(NodeAVL *y) {
    NodeAVL *x = y->left;
    NodeAVL *T = x->right;

    x->right = y;
    y->left = T;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

// --- Rotation gauche pour équilibrage ---
NodeAVL *rotateLeft(NodeAVL *x) {
    NodeAVL *y = x->right;
    NodeAVL *T = y->left;

    y->left = x;
    x->right = T;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

// --- Insertion dans l'arbre AVL ---
NodeAVL *insertNode(NodeAVL *node, Station station) {
    if (!node) {
        return createNode(station);
    }

    if (strcmp(station.id, node->station.id) < 0) {
        node->left = insertNode(node->left, station);
    } else if (strcmp(station.id, node->station.id) > 0) {
        node->right = insertNode(node->right, station);
    } else {
        // Mise à jour des données si la station existe déjà
        node->station.capacity += station.capacity;
        node->station.consumption += station.consumption;
        return node;
    }

    node->height = max(height(node->left), height(node->right)) + 1;

    int balance = height(node->left) - height(node->right);

    if (balance > 1 && strcmp(station.id, node->left->station.id) < 0) {
        return rotateRight(node);
    }

    if (balance < -1 && strcmp(station.id, node->right->station.id) > 0) {
        return rotateLeft(node);
    }

    if (balance > 1 && strcmp(station.id, node->left->station.id) > 0) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    if (balance < -1 && strcmp(station.id, node->right->station.id) < 0) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    return node;
}

// --- Extraction des stations top/min ---
void extractTopStations(NodeAVL *node, Station *topStations, int *count, int topN, int isMax) {
    if (!node || *count >= topN) return;

    extractTopStations(isMax ? node->right : node->left, topStations, count, topN, isMax);

    if (*count < topN) {
        topStations[*count] = node->station;
        (*count)++;
    }

    extractTopStations(isMax ? node->left : node->right, topStations, count, topN, isMax);
}

// --- Lecture et validation d'un fichier CSV ---
NodeAVL *parseCSV(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Erreur lors de l'ouverture du fichier CSV");
        exit(EXIT_FAILURE);
    }

    NodeAVL *root = NULL;
    char line[256];

    while (fgets(line, sizeof(line), file)) {
        Station station;
        if (sscanf(line, "%[^;];%[^;];%[^;];%ld;%ld", station.id, station.parentId, station.name, &station.capacity, &station.consumption) != 5) {
            fprintf(stderr, "Erreur de format : %s", line);
            continue;
        }

        root = insertNode(root, station);
    }

    fclose(file);
    return root;
}

// --- Export des résultats vers un fichier CSV ---
void exportCSV(const char *filename, Station *stations, int count) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        perror("Erreur lors de la création du fichier CSV");
        exit(EXIT_FAILURE);
    }

    fprintf(file, "Station ID;Nom;Capacity (kWh);Consumption (kWh)\n");
    for (int i = 0; i < count; i++) {
        fprintf(file, "%s;%s;%ld;%ld\n", stations[i].id, stations[i].name, stations[i].capacity, stations[i].consumption);
    }

    fclose(file);
    printf("Fichier CSV généré : %s\n", filename);
}

// --- Libération de la mémoire allouée pour l'arbre AVL ---
void freeAVL(NodeAVL *node) {
    if (!node) return;

    freeAVL(node->left);
    freeAVL(node->right);
    free(node);
}

// --- Fonction principale ---
int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Utilisation : %s <fichier_csv> <dossier_sortie>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *inputFile = argv[1];
    const char *outputFolder = argv[2];

    // Lecture des données
    printf("Lecture du fichier : %s\n", inputFile);
    NodeAVL *root = parseCSV(inputFile);

    // Extraction des 10 plus grandes et petites consommations
    Station topStationsMax[TOP_N];
    int countMax = 0;
    extractTopStations(root, topStationsMax, &countMax, TOP_N, 1);

    Station topStationsMin[TOP_N];
    int countMin = 0;
    extractTopStations(root, topStationsMin, &countMin, TOP_N, 0);

    // Export des résultats
    char outputFile[256];
    snprintf(outputFile, sizeof(outputFile), "%s/lv_all_minmax.csv", outputFolder);

    Station combinedStations[TOP_N * 2];
    memcpy(combinedStations, topStationsMin, sizeof(topStationsMin));
    memcpy(combinedStations + TOP_N, topStationsMax, sizeof(topStationsMax));

    exportCSV(outputFile, combinedStations, TOP_N * 2);

    // Libération de la mémoire
    freeAVL(root);

    return EXIT_SUCCESS;
}
